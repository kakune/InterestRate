/**
 * @file core.hpp
 * @brief This defines classes to calculate short rate paths.
 * @author kakune
 * @date 1/29/2024
 */

#ifndef PROCESS_SHORT_RATE_MC_CORE_HPP
#define PROCESS_SHORT_RATE_MC_CORE_HPP

#include <memory>
#include <vector>

#include "math/interpolate_1d.hpp"
#include "process/market_data.hpp"
#include "process/random.hpp"

namespace Process
{
namespace ShortRateMC
{

/**
 * @brief This is the abstract class for short rate models.
 */
class ModelAbstract
{
protected:
    const std::size_t mNPath;        //! the number of Path
    const MarketData::Terms mTerms;  //! term structure
    const double mInitSpotRate;      //! initial spot rate
    /**
     * @brief The coefficient of dt in SDE of r[inIndPath][inIndTerm]
     * @param inIndPath the index of path
     * @param inIndTerm the index of term
     * @return double the coefficient
     */
    virtual double driftCoeff(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<double>>& inSpots ) const = 0;

public:
    /**
     * @brief This constructs a ModelAbstract.
     * @param inNPath the number of Path
     * @param insTerms term structure
     */
    ModelAbstract( std::size_t inNPath, const MarketData::Terms& inTerms,
                   double inInitSpotRate ) :
        mNPath( inNPath ), mTerms( inTerms ), mInitSpotRate( inInitSpotRate )
    {
    }
    virtual ~ModelAbstract() = default;
    /**
     * @brief This calcurate spot rates and Disconunt Factors.
     */
    virtual MarketData::SpotRates calcSpotRates() const;
};

/**
 * @brief This build the object of ModelAbstract.
 */
class ModelAbstractBuilder
{
protected:
    double mInitSpotRate;
    std::size_t mNPath;                          //! the number of Path
    std::unique_ptr<MarketData::Terms> muTerms;  //! term structure

public:
    ModelAbstractBuilder& setNPath( std::size_t inNPath )
    {
        mNPath = inNPath;
        return *this;
    }
    ModelAbstractBuilder& setTerms(
        std::shared_ptr<const std::vector<double>> insTerms )
    {
        muTerms = std::make_unique<MarketData::Terms>( insTerms );
        return *this;
    }
    ModelAbstractBuilder& setTerms( const MarketData::Terms& inTerms )
    {
        muTerms = std::make_unique<MarketData::Terms>( inTerms );
        return *this;
    }
    ModelAbstractBuilder& setInitSpotRate( double inInitSpotRate )
    {
        mInitSpotRate = inInitSpotRate;
        return *this;
    }
    virtual ~ModelAbstractBuilder() = default;
};

/**
 * @brief This is (test) class of constant short-rate model.
 */
class ConstantRate : public ModelAbstract
{
private:
    double driftCoeff(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<double>>& inSpots ) const override;

public:
    ConstantRate( const MarketData::Terms& inTerms, double inInitSpotRate ) :
        ModelAbstract( 1, inTerms, inInitSpotRate )
    {
    }
};

/**
 * @brief This is abstract class for short-rate models generated by
 * one-dimensional Brownian motion.
 */
class OneFactorAbstract : public ModelAbstract
{
protected:
    std::unique_ptr<Process::Random::PathAbstract>
        muRandomPath;  //! random path
    /**
     * @brief The coefficient of dW in SDE of r[inIndPath][inIndTerm]
     * @param inIndPath the index of path
     * @param inIndTerm the index of term
     * @return double the coefficient
     */
    virtual double volCoeff(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<double>>& inSpots ) const = 0;

public:
    OneFactorAbstract(
        std::size_t inNPath, const MarketData::Terms& inTerms,
        double inInitSpotRate,
        std::unique_ptr<Process::Random::PathAbstract> inuRandomPath ) :
        ModelAbstract( inNPath, inTerms, inInitSpotRate ),
        muRandomPath( std::move( inuRandomPath ) )
    {
    }
    virtual MarketData::SpotRates calcSpotRates() const override;
};

class OneFactorAbstractBuilder : public ModelAbstractBuilder
{
protected:
    std::unique_ptr<Process::Random::PathAbstract>
        muRandomPath;  //! random path
public:
    OneFactorAbstractBuilder& setRandom(
        std::unique_ptr<Process::Random::PathAbstract> inuRandomPath )
    {
        muRandomPath = std::move( inuRandomPath );
        return *this;
    }
};

}  // namespace ShortRateMC
}  // namespace Process

#endif