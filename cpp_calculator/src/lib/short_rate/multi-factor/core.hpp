/**
 * @file core.hpp
 * @brief This defines classes to calculate multi-factor short rate paths.
 * @author kakune
 * @date 3/23/2024
 */

#ifndef SHORT_RATE_CORE_HPP
#define SHORT_RATE_CORE_HPP

#include <memory>
#include <vector>

#include "math/matrix.hpp"
#include "process/market_data.hpp"
#include "process/random.hpp"
#include "short_rate/model_data.hpp"

namespace ShortRate
{
namespace MultiFactor
{

/**
 * @brief This is the abstract class for multi-factor short rate models.
 */
class ModelAbstract
{
protected:
    const std::size_t mDim;                   //! the dimension of state
    const std::size_t mNPath;                 //! the number of Path
    const Process::MarketData::Terms mTerms;  //! term structure
    const Math::Vec mInitState;               //! initial spot state
    /**
     * @brief The coefficient of dt in SDE of r[inIndPath][inIndTerm]
     * @param inIndPath the index of path
     * @param inIndTerm the index of term
     * @param inSpots the set of spot states
     * @return Math::Vec the coefficient
     */
    virtual Math::Vec driftCoeff(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<Math::Vec>>& inSpots ) const = 0;

    virtual double transfStateToRate( const Math::Vec& inState,
                                      std::size_t inIndTime ) const;

public:
    /**
     * @brief This constructs a ModelAbstract.
     * @param inNPath the number of Path
     * @param inTerms term structure
     * @param inInitState the initial state
     */
    ModelAbstract( std::size_t inNPath,
                   const Process::MarketData::Terms& inTerms,
                   const Math::Vec& inInitState ) :
        mDim( inInitState.size() ),
        mNPath( inNPath ),
        mTerms( inTerms ),
        mInitState( inInitState )
    {
    }
    virtual ~ModelAbstract() = default;
    /**
     * @brief This calcurate spot rates and Disconunt Factors.
     */
    virtual ShortRate::SpotRates createSpotRates() const;
};

/**
 * @brief This build the object of ModelAbstract.
 */
class ModelAbstractBuilder
{
protected:
    Math::Vec mInitState = Math::makeVec( 0 );            //! initial state
    std::size_t mNPath;                                   //! the number of Path
    std::unique_ptr<Process::MarketData::Terms> muTerms;  //! term structure

public:
    ModelAbstractBuilder& setNPath( std::size_t inNPath )
    {
        mNPath = inNPath;
        return *this;
    }
    ModelAbstractBuilder& setTerms(
        std::shared_ptr<const std::vector<double>> insTerms )
    {
        muTerms = std::make_unique<Process::MarketData::Terms>( insTerms );
        return *this;
    }
    ModelAbstractBuilder& setTerms( const Process::MarketData::Terms& inTerms )
    {
        muTerms = std::make_unique<Process::MarketData::Terms>( inTerms );
        return *this;
    }
    ModelAbstractBuilder& setInitState( const Math::Vec& inInitState )
    {
        mInitState = inInitState;
        return *this;
    }
    virtual ~ModelAbstractBuilder() = default;
};

/**
 * @brief This is (test) class of constant short-rate model.
 */
class ConstantRate : public ModelAbstract
{
private:
    Math::Vec driftCoeff(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<Math::Vec>>& inSpots ) const override;

public:
    ConstantRate( const Process::MarketData::Terms& inTerms,
                  const Math::Vec& inInitState ) :
        ModelAbstract( 1, inTerms, inInitState )
    {
    }
};

/**
 * @brief This is abstract class for short-rate models generated by
 * multi-dimensional Brownian motion.
 */
class MultiFactorAbstract : public ModelAbstract
{
protected:
    std::unique_ptr<Process::RandomVec::StdBrownAbstract>
        muStdBrown;  //! random vec
    /**
     * @brief The shock due to dW in SDE of r[inIndPath][inIndTerm]
     * @param inIndPath the index of path
     * @param inIndTerm the index of term
     * @param inSpots the set of spot states
     * @param inRandomVec the vector of dW
     * @return Math::Vec the shock
     */
    virtual Math::Vec volTerm(
        std::size_t inIndPath, std::size_t inIndTerm,
        const std::vector<std::vector<Math::Vec>>& inSpots,
        const Math::Vec& inRandomVec ) const = 0;

public:
    MultiFactorAbstract(
        std::size_t inNPath, const Process::MarketData::Terms& inTerms,
        const Math::Vec& inInitState,
        std::unique_ptr<Process::RandomVec::StdBrownAbstract> inuStdBrown ) :
        ModelAbstract( inNPath, inTerms, inInitState ),
        muStdBrown( std::move( inuStdBrown ) )
    {
    }
    virtual ShortRate::SpotRates createSpotRates() const override;
};

class MultiFactorAbstractBuilder : public ModelAbstractBuilder
{
protected:
    std::unique_ptr<Process::RandomVec::StdBrownAbstract>
        muStdBrown;  //! random path
public:
    MultiFactorAbstractBuilder& setRandom(
        std::unique_ptr<Process::RandomVec::StdBrownAbstract> inuStdBrown )
    {
        muStdBrown = std::move( inuStdBrown );
        return *this;
    }
};

}  // namespace MultiFactor
}  // namespace ShortRate

#endif